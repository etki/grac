plugins {
    id 'java'
    id 'maven-publish'
    id 'com.jfrog.bintray' version '1.7'
}

group 'me.etki'
version '0.1.3'

apply plugin: 'java'
apply plugin: 'maven-publish'

sourceCompatibility = JavaVersion.VERSION_1_8
targetCompatibility = JavaVersion.VERSION_1_8

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {

    compile group: 'ch.qos.logback', name: 'logback-classic', version: logbackVersion

    compile group: 'org.asynchttpclient', name: 'async-http-client', version: asyncHttpClientVersion

    compile group: 'com.google.guava', name: 'guava', version: guavaVersion

    compile group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: jacksonVersion
    compile group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: jacksonVersion

    testCompile group: 'junit', name: 'junit', version: junitVersion
    testCompile group: 'pl.pragmatists', name: 'JUnitParams', version: junitParamsVersion
    testCompile group: 'org.mockito', name: 'mockito-core', version: mockitoVersion
}

def testTypeStack = []

sourceSets {
    testInfrastructure {
        java {
            srcDir 'src/test-infrastructure/java'
        }
        compileClasspath += main.output
        runtimeClasspath += main.output
        compileClasspath += test.compileClasspath
        runtimeClasspath += test.runtimeClasspath
    }
}

task sourcesJar(type: Jar) {
    classifier = 'sources'
    from sourceSets.main.allJava
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    classifier = 'javadoc'
    from javadoc.destinationDir
}

['unit', 'functional', 'system', 'integration', 'stress'].each { testType ->
    sourceSets.create("${testType}Test") {
        java {
            srcDir 'src/' + testType + '-test/java'
        }
        compileClasspath += sourceSets.main.runtimeClasspath
        compileClasspath += sourceSets.test.runtimeClasspath
        compileClasspath += sourceSets.testInfrastructure.runtimeClasspath
        runtimeClasspath += sourceSets.main.runtimeClasspath
        runtimeClasspath += sourceSets.test.runtimeClasspath
        runtimeClasspath += sourceSets.testInfrastructure.runtimeClasspath
    }

    tasks.create([name: testType + 'Test', type: Test], {
        shouldRunAfter testTypeStack.collect { name -> name + 'Test' }
        testClassesDir = sourceSets."${testType}Test".output.classesDir
        classpath = sourceSets."${testType}Test".runtimeClasspath

        System.properties.entrySet().forEach({ e -> systemProperties[e.key] = e.value })
    })

    testTypeStack.add(testType)
}

task acceptanceTest(dependsOn: [systemTest, integrationTest]) {
    shouldRunAfter test
}

tasks.test.dependsOn(unitTest, functionalTest)
tasks.stressTest.shouldRunAfter acceptanceTest

task release(dependsOn: [acceptanceTest, bintrayUpload])

publishing {
    publications {
        // forcing publication to be last so pom.xml would contain dependencies
        mavenZJava(MavenPublication) {
            from components.java
        }
        mavenSources(MavenPublication) {
            artifact sourcesJar
        }
        mavenJavadoc(MavenPublication) {
            artifact javadocJar
        }
    }
}

bintray {
    user = 'etki'
    key = System.getenv('BINTRAY_API_KEY')
    publications = ['mavenJavadoc', 'mavenSources', 'mavenZJava']

    override = true

    pkg {
        repo = 'maven'
        name = project.name
        licenses = ['MIT']
        labels = ['api-client']
        vcsUrl = 'https://github.com/etki/grac.git'
        websiteUrl = 'https://github.com/etki/grac'
        issueTrackerUrl = 'https://github.com/etki/grac/issues'
        githubRepo = 'etki/grac'
        githubReleaseNotesFile = 'RELEASE.md'
        publicDownloadNumbers = true

        version {
            name = project.version
            desc = 'Generic REST API client'
            vcsTag = project.version
        }
    }
}
